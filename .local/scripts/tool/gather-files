#!/usr/bin/env perl

use v5.40;
use autodie;
use open ':locale';
use utf8;
use warnings     qw(FATAL utf8);
use experimental qw(class declared_refs defer refaliasing);

class Processor 1.000 {
    use Encode       qw(decode);
    use Getopt::Long qw(:config auto_version bundling no_ignore_case);
    use List::Util   qw(any min);
    use Pod::Usage   qw(pod2usage);

    use Cpanel::JSON::XS        qw();
    use Log::Any                qw($log);
    use Log::Any::Adapter       qw(Syslog), ('options' => 'pid,ndelay');
    use Log::Any::Adapter::Util qw(NOTICE TRACE);
    use Path::Tiny              qw(path);

    state $json
        = Cpanel::JSON::XS->new->canonical->utf8(0)->unblessed_bool([1])->pretty->space_before(0)->allow_nonref(1);

    ## no critic [RegularExpressions::ProhibitComplexRegexes]
    state $match_ext = qr{
        (?(DEFINE)
            (?<extension_chars>
                [[:lower:][:digit:]_-] # it must be lower alpha-numerical, underscore or hyphen
            )
        )

        [^\/] # it must have a char before period but not path separator (dir/.perltidyrc shouldn't match)

        ( # group 1: full extension with a period
            [.] # it starts with a period
            ( # group 2: leading period is trimmed
                (?: # it can have optional second level (tar.gz)
                    (?&extension_chars){2,}
                    [.]
                )?
                (?&extension_chars){1,} # it should be at least one symbol (out.o)
            )
        )

        \z # must be at the end of the path
    }x;

    field $follow  = 0;
    field $recurse = 0;
    field $verbose = 0;
    field %stats;
    field @exclude = (qr{/\@eaDir/}, qr{/\#snapshot/});
    field @include;

    ADJUST {
        GetOptions(
            'exclude|e=s' => (my $exclude_args = []),
            'follow|f'    => \$follow,
            'help|h'      => sub {pod2usage('-verbose' => 99, 'exitval' => 0)},
            'include|i=s' => (my $include_args = []),
            'recurse|r'   => \$recurse,
            'verbose|v+'  => \$verbose,
        ) or die $log->fatal('Unable to process command line options') . "\n";

        Log::Any::Adapter->set(
            'Multiplex',
            'adapters' => {
                'Syslog' => ['log_level' => 'warning', 'options' => 'pid,ndelay'],
                'Stderr' => ['log_level' => min(TRACE(), NOTICE() + $verbose)],
            },
        );

        push(@ARGV,    '.') unless @ARGV;
        push(@exclude, map {qr{$_}} $exclude_args->@*);
        push(@include, map {qr{$_}} $include_args->@*);

        return $self;
    }

    method execute() {
        my @found;

        $log->trace('gathering files started');

        foreach my $arg (map {path($_)} @ARGV) {
            unless (-d $arg) {
                $self->_process_path(\@found, $arg);
                next;
            }

            $arg->visit(
                sub($path, @) {$self->_process_path(\@found, $path)},
                {
                    'follow_symlinks' => $follow,
                    'recurse'         => $recurse,
                },
            );
        }

        $log->debugf('gathering files finished: %d', $stats{'files_count'});

        @found = sort {$a->{path} cmp $b->{path}} @found;

        say $json->encode(\@found);

        return 0;
    }

    method _process_path($found_aref, $path) {
        $path = path(decode('UTF-8', $path->stringify, Encode::FB_CROAK));

        return unless $self->_is_valid_path($path);
        return unless $self->_is_included_path($path);
        return if $self->_is_excluded_path($path);

        $log->tracef('found: %s', $path);
        ++$stats{'files_count'};

        my $stat = $path->stat;
        my ($match, $ext) = $path =~ $match_ext;

        push(
            $found_aref->@*,
            {
                'ext'  => $ext,
                'name' => $path->basename($match // ()),
                'path' => $path->stringify,
                'stat' => sprintf('%d/%d', $stat->dev, $stat->ino),
            },
        );
    }

    method _is_valid_path($path) {
        return $path->is_file && !-l $path;
    }

    method _is_included_path($path) {
        my $result = !@include || any {$path =~ $_} @include;
        $log->tracef('skipped: %s', $path) unless $result;
        return $result;
    }

    method _is_excluded_path($path) {
        my $result = @exclude && any {$path =~ $_} @exclude;
        $log->tracef('excluded: %s', $path) if $result;
        return $result;
    }
}

exit Processor->new->execute();

__END__
