#!/usr/bin/env bash

set -Eeuo pipefail

echo "$0" "$@" &>>"$XDG_RUNTIME_DIR/cred.log"

# default to https protocol
if [[ ! "${url:=${1?url must be provided}}" =~ \:\/\/ ]]; then
    url="https://$url"
fi

# rewrite some urls to use the same token (usefull for the cases many sites use the same auth and token can be reused)
domain='boo''king'
host_orig="$(git-parse-url "$url" | grep -Pom1 '^host=\K.+' 2>/dev/null)"
if eval "[[ '$url' =~ prod\.$domain\.com ]]"; then
    host_rewrite="sso.prod.$domain.com"
    url="https://$host_rewrite"
elif eval "[[ '$url' =~ dqs\.$domain\.com ]]"; then
    host_rewrite="sso.dqs.$domain.com"
    url="https://$host_rewrite"
fi

# fetch credentials via git
credentials="$(git credential fill <<< "url=$url" | sort)"

# expose std input lines as key=value variables
# `source <(cat)` approach is not working because it fails if there is a space in values
while read -r line; do
    declare -- "$line"
done <<< "$credentials"

# simplistic check if approve can be called, no real usage of password
# it's necessary because without approve auth and refresh token will not be saved in cache
# and oauth helper will try to re-authentify every call
if [[ -n "${username:-}" && -n "${password:-}" ]]; then
    git credential approve <<< "$credentials"
fi >&2

if [[ -t 1 ]]; then
    password_hash="$(grep -Pm1 '^password=' 2>/dev/null <<< "$credentials" | sha1sum)"
    credentials="$(sed -E $'s/^(password|oauth_refresh_token)=(.{1,5}).*$/\\1=\\2*****\e[91m<redacted for TTY output>\e[0m/' <<< "$credentials")"
fi

current_script="$(basename "$0")"
if [[ "$current_script" =~ p$ ]]; then
    exec grep -Pom1 '^password=\K.+' 2>/dev/null <<< "$credentials"
fi

if [[ ! -t 1 ]]; then
    exec cat <<< "$credentials"
fi

# rewrite host back if it was rewritten before
if [[ -n "${host_rewrite:-}" ]]; then
    sed -E "s/^(host)=.*$/\1=$host_orig/" <<< "$credentials"
else
    echo "$credentials"
fi

if [[ -t 2 ]]; then
    [[ -n "${host_rewrite:-}" && "${host_orig:-}" != "${host_rewrite:-}" ]] && >&2 echo "> host was rewritten to use common token: $host_rewrite"
    >&2 echo "> password fingerprint: $password_hash"
    # nice to know when password will expire in a human readable form (print only if tty)
    if [[ -n "${password_expiry_utc:-}" ]]; then
        >&2 echo -n "> password expires at: $(date -d "@$password_expiry_utc" --rfc-3339=seconds)"
        if [[ -x "$(command -v datediff)" ]]; then
            >&2 echo -n ' (in:' "$(datediff now "@$password_expiry_utc" -f "%H:%M:%S" || true)"')'
        fi
        >&2 echo
    fi
fi
