#!/usr/bin/env -S just --one --justfile

# https://just.systems/man/en/

xh := require('xh') # https://github.com/ducaale/xh#installation

set export

# generic http request using full url, provides diagnostics on failure
[group('http'), private, no-cd, positional-arguments, no-exit-message]
generic-http-request method url *argv:
    #!/usr/bin/env -S bash -Eeuo pipefail
    shift 2
    method="${method@U}"
    args=(
        "$url"
        --https
        --ignore-stdin
        --no-follow
    )

    cmd=(xh "$method" "${args[@]}" "$@")

    if [[ -n "${XH_DEBUG:-}" ]]; then
        if [[ "$XH_DEBUG" == "curl" ]]; then
            >&2 "${cmd[@]}" --curl
        elif [[ -x "$(command -v args2log)" ]]; then
            >&2 args2log "${cmd[@]}"
        else
            >&2 echo "${cmd[@]@Q}"
        fi
    fi

    [[ -t 1 ]] && exec "${cmd[@]}"

    # this should be done by the tool automatically but for now this is a required workaround
    # because output is collected and parsed - all warnings are suppressed and only exact output is set to be printed
    # this is not necessary to do if output is to TTY (above), hence difference in options
    # much better solution would be if some output parts could be redirected to STDERR or other handle making sure main
    # response body doesn't share STDOUT with other pieces of output
    if [[ "$method" == 'HEAD' || "$method" == 'OPTIONS' ]]; then
        args+=(-qq --print=h)
    else
        args+=(-qq --print=b)
    fi

    [[ "${XH_ALLOW_ERROR:-0}" == '0' ]] || args+=(--no-check-status)

    if res="$(xh "$method" "${args[@]}" "$@")"; then
        echo "$res"
    else
        errno="$?"
        {
            >&2 echo '> error in the following HTTP request:'
            >&2 echo
            if [[ -x "$(command -v args2log)" ]]; then
                >&2 args2log "${cmd[@]}"
            else
                >&2 echo "${cmd[@]@Q}"
            fi
            >&2 echo
            >&2 "${cmd[@]}" --print=HB --offline --pretty=all
            >&2 echo "$res"
        } 2>&1 | "$PAGER" >/dev/tty
        exit "$errno"
    fi

# HTTP request provides body via stdin (not for GET or HEAD)
[group('http'), private, no-cd, positional-arguments, no-exit-message]
http-request-stdin method uri *argv:
    #!/usr/bin/env -S bash -Eeuo pipefail
    shift 2
    # this recipe requires caller to implement http-request recipe (with proper auth or other customization)
    # it's used as a common solution - wrapper around custom http-request for all callers
    "$this" http-request "$method" "$uri" --no-ignore-stdin "$@"

# streaming http request using full url
[group('http'), private, no-cd, positional-arguments, no-exit-message]
streaming-http-request method url *argv:
    #!/usr/bin/env -S bash -Eeuo pipefail
    shift 2
    args=(
        "$url"
        --https
        --ignore-stdin
        --no-follow
        --stream
    )
    # it's impossible to use generic-http-request here because it collects all output for debuuging and this is
    # absolutely incompatible with the main purpose of this function - streaming of the output
    xh "${method@U}" "${args[@]}" "$@"

# => helpers ------------------------------------------------------------------------------------------------------ {{{1

[group('helpers'), private, no-cd, no-exit-message]
@fatal message:
    >&2 echo "{{style('error')}}$message{{NORMAL}}"
    exit 1

[group('helpers'), private, no-cd]
@print message:
    [[ -t 1 ]] && >&2 echo "{{style('warning')}}$message{{NORMAL}}" || true

# parse raw HTTP headers to JSON, support multi-value headers (set-cookie for example)
[group('helpers'), private, no-cd]
headers2json:
    #!/usr/bin/env -S bash -Eeu
    tail -n +2 \
        | perl -lnE 'm/^$/x and exit; m/^ [[:alnum:].+-_]+? :/x and say s/^ ([^:]+?) : \s* (.+)/$1\t$2/xr' \
        | sort -u \
        | jq -nRS '[inputs | split("\t") | {key: (.[0] | ascii_downcase), value: .[1]}]
            | group_by(.key)
            | map( { (.[0].key): ([.[] .value] | if length == 1 then .[0] else . end) } )
            | add'

# trim all leading and trailing whitespaces for the whole input
[group('helpers'), private, no-cd]
@trim-whole:
    perl -g -pE '$_ = trim($_); END {say}'
